[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Kinodynamic Compendium",
    "section": "",
    "text": "1 Introduction\nThis is a summary of important kinodynamic systems of varying complexity to simplify research and benchmarking in the area of motion planning and controls, for single- and multi-robot systems.\nParticular emphasis is on including results such as differential flatness, interesting instances (with respect to bounds), and relationship to real robots.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "1st_order/single_integrator.html",
    "href": "1st_order/single_integrator.html",
    "title": "2  Single Integrator (2D)",
    "section": "",
    "text": "2.1 Dynamics",
    "crumbs": [
      "First Order Systems",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Single Integrator (2D)</span>"
    ]
  },
  {
    "objectID": "1st_order/single_integrator.html#dynamics",
    "href": "1st_order/single_integrator.html#dynamics",
    "title": "2  Single Integrator (2D)",
    "section": "",
    "text": "Parameters\n\nstate space \\(\\mathcal{X}\\)\naction space \\(\\mathcal{U}\\)\n\nState: \\(\\mathbf{x}= \\begin{pmatrix}x, y\\end{pmatrix}^\\top \\in \\mathcal{X}\\) [m, m] (position of the robot in the world frame)\nAction: \\(\\mathbf{u}= \\begin{pmatrix} v_x, v_y \\end{pmatrix}^\\top \\in \\mathcal{U}\\) [m/s, m/s] (speed of the robot in the world frame)\nDynamics: \\[\n  \\begin{aligned}\n      \\dot x &= v_x\\\\\n      \\dot y &= v_y \\\\\n  \\end{aligned}\n  \\]",
    "crumbs": [
      "First Order Systems",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Single Integrator (2D)</span>"
    ]
  },
  {
    "objectID": "1st_order/single_integrator.html#differential-flatness",
    "href": "1st_order/single_integrator.html#differential-flatness",
    "title": "2  Single Integrator (2D)",
    "section": "2.2 Differential Flatness",
    "text": "2.2 Differential Flatness\nPick flat outputs \\(\\mathbf{z}(t) = (x(t), y(t))^\\top\\), i.e., the position of the robot. Then we can compute all necessary variables if \\(\\mathbf{z}(t)\\) is at least C1-continuous. \\[\n\\begin{aligned}\n    \\mathbf{x}(t) &= g_x(\\mathbf{z}) = \\left(x, y\\right)\\\\\n    \\mathbf{u}(t) &= g_u(\\dot{\\mathbf{z}}) = \\left(\\dot x, \\dot y \\right)\n\\end{aligned}\n\\]",
    "crumbs": [
      "First Order Systems",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Single Integrator (2D)</span>"
    ]
  },
  {
    "objectID": "1st_order/single_integrator.html#invariance",
    "href": "1st_order/single_integrator.html#invariance",
    "title": "2  Single Integrator (2D)",
    "section": "2.3 Invariance",
    "text": "2.3 Invariance\nThe dynamics are translation-invariant.",
    "crumbs": [
      "First Order Systems",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Single Integrator (2D)</span>"
    ]
  },
  {
    "objectID": "1st_order/single_integrator.html#controllers",
    "href": "1st_order/single_integrator.html#controllers",
    "title": "2  Single Integrator (2D)",
    "section": "2.4 Controllers",
    "text": "2.4 Controllers\nThe system is linear, so an LQR controller is most suitable.",
    "crumbs": [
      "First Order Systems",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Single Integrator (2D)</span>"
    ]
  },
  {
    "objectID": "1st_order/single_integrator.html#useful-parameters",
    "href": "1st_order/single_integrator.html#useful-parameters",
    "title": "2  Single Integrator (2D)",
    "section": "2.5 Useful Parameters",
    "text": "2.5 Useful Parameters\n\n2.5.1 integrator1_2d_v0 (Ortiz-Haro et al. (2024))\n\nA basic version \\[\n\\mathcal{U}= [-0.5, 0.5] m/s \\times [-0.5, 0.5] ms/s\n\\]\n\n\n\n\nOrtiz-Haro, Joaquim, Wolfgang Hönig, Valentin N. Hartmann, and Marc Toussaint. 2024. “iDb-a*: Iterative Search and Optimization for Optimal Kinodynamic Motion Planning.” IEEE Transactions on Robotics, 1–19. https://doi.org/10.1109/TRO.2024.3502505.",
    "crumbs": [
      "First Order Systems",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Single Integrator (2D)</span>"
    ]
  },
  {
    "objectID": "1st_order/unicycle.html",
    "href": "1st_order/unicycle.html",
    "title": "3  Unicycle",
    "section": "",
    "text": "3.1 Dynamics",
    "crumbs": [
      "First Order Systems",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Unicycle</span>"
    ]
  },
  {
    "objectID": "1st_order/unicycle.html#dynamics",
    "href": "1st_order/unicycle.html#dynamics",
    "title": "3  Unicycle",
    "section": "",
    "text": "Parameters\n\nstate space \\(\\mathcal{X}\\)\naction space \\(\\mathcal{U}\\)\n\nState: \\(\\mathbf{x}= \\begin{pmatrix}x, y, \\theta\\end{pmatrix}^\\top \\in \\mathcal{X}\\) [m, m, rad] (position and orientation of the robot in the world frame)\nAction: \\(\\mathbf{u}= \\begin{pmatrix} v, \\omega \\end{pmatrix}^\\top \\in \\mathcal{U}\\) [m/s, rad/s] (speed and angular speed, respectively)\nDynamics: \\[\n  \\begin{aligned}\n      \\dot x &= v \\cos \\theta \\\\\n      \\dot y &= v \\sin \\theta \\\\\n      \\dot \\theta &= \\omega\n  \\end{aligned}\n  \\]",
    "crumbs": [
      "First Order Systems",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Unicycle</span>"
    ]
  },
  {
    "objectID": "1st_order/unicycle.html#differential-flatness",
    "href": "1st_order/unicycle.html#differential-flatness",
    "title": "3  Unicycle",
    "section": "3.2 Differential Flatness",
    "text": "3.2 Differential Flatness\nPick flat outputs \\(\\mathbf{z}(t) = (x(t), y(t))^\\top\\), i.e., the position of the unicycle. Then we can compute all necessary variables if \\(\\mathbf{z}(t)\\) is at least C2-continuous. \\[\n\\begin{aligned}\n        \\mathbf{x}(t) &= g_x(\\mathbf{z}, \\dot{\\mathbf{z}}) = \\left(x, y, \\arctan \\left(\\frac{\\dot y}{\\dot x}\\right)\\right)\\\\\n        \\mathbf{u}(t) &= g_u(\\dot{\\mathbf{z}}, \\ddot{\\mathbf{z}}) = \\left({\\color{red} \\pm}\\sqrt{\\dot y^2 + \\dot x^2}, \\frac{\\dot x \\ddot y - \\dot y \\ddot x}{\\dot x^2 + \\dot y^2} \\right)\n      \\end{aligned}\n\\]\n\n\n\n\n\n\nNoteDerivation\n\n\n\n\n\nDivide y and x-part of the dynamics, yields \\(\\theta\\): \\[\n\\begin{aligned}\n        \\frac{\\dot y}{\\dot x} &= \\frac{v \\sin \\theta}{v \\cos \\theta}\\\\\n        \\frac{\\dot y}{\\dot x} &= \\tan \\theta\\\\\n        \\theta &= \\arctan \\left(\\frac{\\dot y}{\\dot x}\\right)\n\\end{aligned}\n\\]\nUsing the x-part, rearranging for \\(v\\) and substituting the expression for \\(\\theta\\), yields \\(v\\): \\[\n\\begin{aligned}\n    v &= \\frac{\\dot x}{\\cos \\theta}\\\\\n    &= \\frac{\\dot x}{\\cos \\left(\\arctan \\left(\\frac{\\dot y}{\\dot x}\\right)\\right)}\\\\\n    &= \\dot x \\sqrt{\\frac{\\dot y^2}{\\dot x^2} + 1} = \\dot x \\sqrt{\\frac{\\dot y^2}{\\dot x^2} + \\frac{\\dot x^2}{\\dot x^2}}\\\\\n    &= {\\color{red} \\pm}\\sqrt{\\dot y^2 + \\dot x^2}\n\\end{aligned}\n\\]\nTaking the time-derivative of the expression for \\(\\theta\\) yields \\(\\omega\\) \\[\n\\begin{aligned}\n    \\omega &= \\dot \\theta = \\frac{d}{dt} \\arctan \\left(\\frac{\\dot y}{\\dot x}\\right)\\\\\n          &= \\frac{\\dot x \\ddot y - \\dot y \\ddot x}{\\dot x^2 + \\dot y^2}\n\\end{aligned}\n\\]",
    "crumbs": [
      "First Order Systems",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Unicycle</span>"
    ]
  },
  {
    "objectID": "1st_order/unicycle.html#invariance",
    "href": "1st_order/unicycle.html#invariance",
    "title": "3  Unicycle",
    "section": "3.3 Invariance",
    "text": "3.3 Invariance\nThe dynamics are translation-invariant.",
    "crumbs": [
      "First Order Systems",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Unicycle</span>"
    ]
  },
  {
    "objectID": "1st_order/unicycle.html#controllers",
    "href": "1st_order/unicycle.html#controllers",
    "title": "3  Unicycle",
    "section": "3.4 Controllers",
    "text": "3.4 Controllers\n\n3.4.1 Geometric Controller (Kanayama et al. (1990))\n\nGiven reference state \\(\\mathbf{x}_r = \\begin{pmatrix}x_r, y_r, \\theta_r\\end{pmatrix}^\\top \\in \\mathcal{X}\\) and reference action \\(\\mathbf{u}_r = \\begin{pmatrix} v_r, \\omega_r \\end{pmatrix}^\\top \\in \\mathcal{U}\\)\n\\(K_x, K_y, K_\\theta\\in\\mathbb R^+\\) are tuning gains\nControl law: \\[\\begin{aligned}\n  x_e &= (x_r-x)\\cos \\theta + (y_r-y)\\sin \\theta\\\\\n  y_e &= -(x_r-x)\\sin \\theta + (y_r-y)\\cos \\theta\\\\\n  \\theta_e &= \\theta_d \\ominus \\theta \\\\\n  v &= v_r \\cos \\theta_e + K_x x_e\\\\\n  \\omega &= \\omega_r + v_r (K_y y_e + K_\\theta \\sin \\theta_e)\n  \\end{aligned}\n  \\]\n\n\n\n3.4.2 Action Mixing\nGeometric controllers might output actions that are outside the nominal action space \\(\\mathcal{U}\\) (saturation limits). To remedy this, a QP can be used that prefers \\(\\omega\\) over \\(v\\) using a tuning parameter \\(\\lambda\\):\n\\[\n\\begin{aligned}\n\\min_{v^*, \\omega^*} & \\, (\\omega^* - \\omega) ^2 + \\lambda (v^* - v)^2 \\\\\n\\text{s.t.} & \\,\n\\begin{pmatrix} v^*, \\omega^* \\end{pmatrix}^\\top \\in \\mathcal{U}\n\\end{aligned}\n\\]",
    "crumbs": [
      "First Order Systems",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Unicycle</span>"
    ]
  },
  {
    "objectID": "1st_order/unicycle.html#useful-parameters",
    "href": "1st_order/unicycle.html#useful-parameters",
    "title": "3  Unicycle",
    "section": "3.5 Useful Parameters",
    "text": "3.5 Useful Parameters\n\n3.5.1 unicycle1_v0 (Ortiz-Haro et al. (2024))\n\nA basic version \\[\n\\mathcal{U}= [-0.5, 0.5] m/s \\times [-0.5, 0.5] rad/s\n\\]\n\n\n3.5.2 unicycle1_v1 (Ortiz-Haro et al. (2024))\n\nA plane-like version with minimum speed\n\\[\n\\mathcal{U}= [0.25, 0.5] m/s \\times [-0.5, 0.5] rad/s\n\\]\n\n\n3.5.3 unicycle1_v2 (Ortiz-Haro et al. (2024))\n\nA plane-like version with a rudder damage\n\\[\n\\mathcal{U}= [0.25, 0.5] m/s \\times [-0.25, 0.5] rad/s\n\\]\n\n\n\n\nChoset, Howie, Kevin M. Lynch, Seth Hutchinson, George A. Kantor, Wolfram Burgard, Lydia E. Kavraki, and Sebastian Thrun. 2005. Principles of Robot Motion: Theory, Algorithms, and Implementations. Edited by Ronald C. Arkin. Intelligent Robotics and Autonomous Agents Series. Cambridge, MA, USA: A Bradford Book.\n\n\nKanayama, Y., Y. Kimura, F. Miyazaki, and T. Noguchi. 1990. “A Stable Tracking Control Method for an Autonomous Mobile Robot.” In IEEE International Conference on Robotics and Automation (ICRA), 384–89. https://doi.org/10.1109/ROBOT.1990.126006.\n\n\nOrtiz-Haro, Joaquim, Wolfgang Hönig, Valentin N. Hartmann, and Marc Toussaint. 2024. “iDb-a*: Iterative Search and Optimization for Optimal Kinodynamic Motion Planning.” IEEE Transactions on Robotics, 1–19. https://doi.org/10.1109/TRO.2024.3502505.",
    "crumbs": [
      "First Order Systems",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Unicycle</span>"
    ]
  },
  {
    "objectID": "1st_order/diffdrive.html",
    "href": "1st_order/diffdrive.html",
    "title": "4  Differential Drive",
    "section": "",
    "text": "4.1 Dynamics",
    "crumbs": [
      "First Order Systems",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Differential Drive</span>"
    ]
  },
  {
    "objectID": "1st_order/diffdrive.html#dynamics",
    "href": "1st_order/diffdrive.html#dynamics",
    "title": "4  Differential Drive",
    "section": "",
    "text": "Parameters\n\n\\(r\\): radius of the wheels [m]\n\\(L\\): distance between the wheels [m]\n\nState: \\(\\mathbf{x}= \\begin{pmatrix}x, y, \\theta\\end{pmatrix}^\\top\\) [m, m, rad] (position and orientation of the robot in the world frame)\nAction: \\(\\mathbf{u}= \\begin{pmatrix} u_l, u_r \\end{pmatrix}^\\top\\) [rad/s, rad/s] (angular velocity of the left and right wheels, respectively)\nDynamics: \\[\n  \\begin{aligned}\n      \\dot x &= \\frac{r}{2} (u_l + u_r) \\cos \\theta \\\\\n      \\dot y &= \\frac{r}{2} (u_l + u_r) \\sin \\theta \\\\\n      \\dot \\theta &= \\frac{r}{L} (u_r - u_l)\n  \\end{aligned}\n  \\]\n\n\n4.1.1 Relationship to Unicycle\nThere is a linear relationship between the differential drive and the unicycle. One can substitute actions to \\(v = \\frac{r}{2} (u_l + u_r)\\) and \\(\\omega = \\frac{r}{L} (u_r - u_l)\\) to get \\[\n\\begin{aligned}\n        \\dot x &= v \\cos \\theta \\\\\n        \\dot y &= v \\sin \\theta \\\\\n        \\dot \\theta &= \\omega\n    \\end{aligned}\n\\]\nThen, the “original” actions can be computed as \\[\\begin{aligned}\n    u_l &= \\frac{2v-L\\omega}{2r}\\\\\n    u_r &= \\frac{2v + L\\omega}{2r}\n\\end{aligned}\n\\]\n\n\n\n\n\n\nNoteDerivation\n\n\n\n\n\n\\[\n2v = r (u_l + u_r)\n\\tag{4.1}\\]\n\\[\nL\\omega = r (u_r - u_l)\n\\tag{4.2}\\]\nAdding Equation 4.1 and Equation 4.2:\n\\[\n\\begin{aligned}\n2v + L\\omega = r (u_l + u_r + u_r - u_l) = 2 r u_r\\\\\nu_r = \\frac{2v + L\\omega}{2 r}\n\\end{aligned}\n\\tag{4.3}\\]\nSubstituting Equation 4.3 in Equation 4.1: \\[\n\\begin{aligned}\n2v = r (u_l + u_r) = r (u_l + \\frac{2v + L\\omega}{2 r}) = r u_l + v + \\frac{L\\omega}{2}\\\\\nu_l = \\frac{2v - v - \\frac{L\\omega}{2}}{r} = \\frac{2v - L \\omega}{2 r}\n\\end{aligned}\n\\tag{4.4}\\]",
    "crumbs": [
      "First Order Systems",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Differential Drive</span>"
    ]
  },
  {
    "objectID": "1st_order/diffdrive.html#differential-flatness",
    "href": "1st_order/diffdrive.html#differential-flatness",
    "title": "4  Differential Drive",
    "section": "4.2 Differential Flatness",
    "text": "4.2 Differential Flatness\nPick flat outputs \\(\\mathbf{z}(t) = (x(t), y(t))^\\top\\), i.e., the position of the robot. Then we can compute all necessary variables if \\(\\mathbf{z}(t)\\) is at least C2-continuous. \\[\n\\begin{aligned}\n    \\mathbf{x}(t) &= g_x(\\mathbf{z}, \\dot{\\mathbf{z}}) = \\left(x, y, \\arctan \\left(\\frac{\\dot y}{\\dot x}\\right)\\right)\\\\\n    \\mathbf{u}(t) &= g_u(\\dot{\\mathbf{z}}, \\ddot{\\mathbf{z}}) = \\left(\\frac{2v-L\\omega}{2r}, \\frac{2v + L\\omega}{2r}\\right), \\text{ where }\\\\\n    v &= {\\color{red} \\pm}\\sqrt{\\dot y^2 + \\dot x^2}\\\\\n    \\omega &= \\frac{\\dot x \\ddot y - \\dot y \\ddot x}{\\dot x^2 + \\dot y^2}\n\\end{aligned}\n\\]\n\n\n\n\n\n\nNoteDerivation\n\n\n\n\n\nOne can apply the same differential flatness result from the unicycle, followed by the linear mapping derived earlier to recover the actual actions \\(g_u\\).",
    "crumbs": [
      "First Order Systems",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Differential Drive</span>"
    ]
  },
  {
    "objectID": "1st_order/diffdrive.html#invariance",
    "href": "1st_order/diffdrive.html#invariance",
    "title": "4  Differential Drive",
    "section": "4.3 Invariance",
    "text": "4.3 Invariance\nThe dynamics are translation-invariant.",
    "crumbs": [
      "First Order Systems",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Differential Drive</span>"
    ]
  },
  {
    "objectID": "1st_order/diffdrive.html#controllers",
    "href": "1st_order/diffdrive.html#controllers",
    "title": "4  Differential Drive",
    "section": "4.4 Controllers",
    "text": "4.4 Controllers\n\n4.4.1 Geometric Controller (Kanayama et al. (1990))\nThis is the same controller as for the unicycle, with the linear mapping applied.\n\nGiven reference state \\(\\mathbf{x}_r = \\begin{pmatrix}x_r, y_r, \\theta_r\\end{pmatrix}^\\top \\in \\mathcal{X}\\) and reference action \\(\\mathbf{u}_r = \\begin{pmatrix} u_{l,r}, u_{r,r} \\end{pmatrix}^\\top \\in \\mathcal{U}\\)\n\\(K_x, K_y, K_\\theta\\in\\mathbb R^+\\) are tuning gains\nControl law: \\[\\begin{aligned}\n  v_r &= \\frac{r}{2} (u_{l,r} + u_{r,r})\\\\\n  \\omega_r &= \\frac{r}{L} (u_{r,r} - u_{l,r})\\\\\n  x_e &= (x_r-x)\\cos \\theta + (y_r-y)\\sin \\theta\\\\\n  y_e &= -(x_r-x)\\sin \\theta + (y_r-y)\\cos \\theta\\\\\n  \\theta_e &= \\theta_d \\ominus \\theta \\\\\n  v &= v_r \\cos \\theta_e + K_x x_e\\\\\n  \\omega &= \\omega_r + v_r (K_y y_e + K_\\theta \\sin \\theta_e)\\\\\n  u_l &= \\frac{2v-L\\omega}{2r}\\\\\n  u_r &= \\frac{2v + L\\omega}{2r}\n  \\end{aligned}\n  \\]\n\n\n\n4.4.2 Action Mixing\nGeometric controllers might output actions that are outside the nominal action space \\(\\mathcal{U}\\) (saturation limits). To remedy this, a QP can be used that prefers \\(\\omega\\) over \\(v\\) using a tuning parameter \\(\\lambda\\):\n\\[\n\\begin{aligned}\n\\min_{v^*, \\omega^*} & \\, (\\omega^* - \\omega) ^2 + \\lambda (v^* - v)^2 \\\\\n\\text{s.t.} & \\,\n\\begin{pmatrix} \\frac{2v^*-L\\omega^*}{2r}, \\frac{2v^* + L\\omega^*}{2r} \\end{pmatrix}^\\top \\in \\mathcal{U}\n\\end{aligned}\n\\]\nfollowed by converting the result back to the desired control values:\n\\[\\begin{aligned}\nu_l &= \\frac{2v^*-L\\omega^*}{2r}\\\\\nu_r &= \\frac{2v^* + L\\omega^*}{2r}\n\\end{aligned}\n\\]",
    "crumbs": [
      "First Order Systems",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Differential Drive</span>"
    ]
  },
  {
    "objectID": "1st_order/diffdrive.html#useful-parameters",
    "href": "1st_order/diffdrive.html#useful-parameters",
    "title": "4  Differential Drive",
    "section": "4.5 Useful Parameters",
    "text": "4.5 Useful Parameters\n\n4.5.1 pololu-3piplus-hyper\nCommercially off-the-shelves (Cots) robot: Pololu 3pi+ Hyper Edition\n\\[\\begin{aligned}\nL &= 0.089\\\\\nr &= 0.016\\\\\n\\mathcal{U}&= [-157.08, 157.08] rad/s \\times [-157.08, 157.08] rad/s\n\\end{aligned}\n\\]\n\n\n\n\nKanayama, Y., Y. Kimura, F. Miyazaki, and T. Noguchi. 1990. “A Stable Tracking Control Method for an Autonomous Mobile Robot.” In IEEE International Conference on Robotics and Automation (ICRA), 384–89. https://doi.org/10.1109/ROBOT.1990.126006.\n\n\nLaValle, Steven M. 2006. Planning Algorithms. Cambridge University Press.",
    "crumbs": [
      "First Order Systems",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Differential Drive</span>"
    ]
  },
  {
    "objectID": "1st_order/car.html",
    "href": "1st_order/car.html",
    "title": "5  Car",
    "section": "",
    "text": "5.1 Dynamics",
    "crumbs": [
      "First Order Systems",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Car</span>"
    ]
  },
  {
    "objectID": "1st_order/car.html#dynamics",
    "href": "1st_order/car.html#dynamics",
    "title": "5  Car",
    "section": "",
    "text": "Parameters\n\n\\(L\\): distance between the wheels [m]\nstate space \\(\\mathcal{X}\\)\naction space \\(\\mathcal{U}\\)\n\nState: \\(\\mathbf{x}= \\begin{pmatrix}x, y, \\theta\\end{pmatrix}^\\top \\in \\mathcal{X}\\) [m, m, rad] (position and orientation of the robot in the world frame)\nAction: \\(\\mathbf{u}= \\begin{pmatrix} v, \\phi \\end{pmatrix}^\\top \\in \\mathcal{U}\\) [m/s, rad] (speed and front wheel angle, respectively)\nDynamics: \\[\n  \\begin{aligned}\n      \\dot x &= v \\cos \\theta\\\\\n      \\dot y &= v \\sin \\theta\\\\\n      \\dot \\theta &= \\frac{v}{L} \\tan \\phi\n  \\end{aligned}\n  \\]",
    "crumbs": [
      "First Order Systems",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Car</span>"
    ]
  },
  {
    "objectID": "1st_order/car.html#differential-flatness",
    "href": "1st_order/car.html#differential-flatness",
    "title": "5  Car",
    "section": "5.2 Differential Flatness",
    "text": "5.2 Differential Flatness\nPick flat outputs \\(\\mathbf{z}(t) = (x(t), y(t))^\\top\\), i.e., the position of the unicycle. Then we can compute all necessary variables if \\(\\mathbf{z}(t)\\) is at least C2-continuous. \\[\n\\begin{aligned}\n    \\mathbf{x}(t) &= g_x(\\mathbf{z}, \\dot{\\mathbf{z}}) = \\left(x, y, \\arctan \\left(\\frac{\\dot y}{\\dot x}\\right)\\right)\\\\\n    \\mathbf{u}(t) &= g_u(\\dot{\\mathbf{z}}, \\ddot{\\mathbf{z}}) = \\left({\\color{red} \\pm}\\sqrt{\\dot y^2 + \\dot x^2}, \\arctan \\frac{L(\\dot x \\ddot y - \\dot y \\ddot x)}{(\\dot x^2 + \\dot y^2)^{3/2}} \\right)\n\\end{aligned}\n\\]\n\n\n\n\n\n\nNoteDerivation\n\n\n\n\n\nDivide y and x-part of the dynamics, yields \\(\\theta\\): \\[\n\\begin{aligned}\n        \\frac{\\dot y}{\\dot x} &= \\frac{v \\sin \\theta}{v \\cos \\theta}\\\\\n        \\frac{\\dot y}{\\dot x} &= \\tan \\theta\\\\\n        \\theta &= \\arctan \\left(\\frac{\\dot y}{\\dot x}\\right)\n\\end{aligned}\n\\]\nUsing the x-part, rearranging for \\(v\\) and substituting the expression for \\(\\theta\\), yields \\(v\\): \\[\n\\begin{aligned}\n    v &= \\frac{\\dot x}{\\cos \\theta}\\\\\n    &= \\frac{\\dot x}{\\cos \\left(\\arctan \\left(\\frac{\\dot y}{\\dot x}\\right)\\right)}\\\\\n    &= \\dot x \\sqrt{\\frac{\\dot y^2}{\\dot x^2} + 1} = \\dot x \\sqrt{\\frac{\\dot y^2}{\\dot x^2} + \\frac{\\dot x^2}{\\dot x^2}}\\\\\n    &= {\\color{red} \\pm}\\sqrt{\\dot y^2 + \\dot x^2}\n\\end{aligned}\n\\]\nTaking the time-derivative of the expression for \\(\\theta\\) yields \\(\\dot \\theta\\) \\[\n\\begin{aligned}\n    \\dot \\theta &= \\frac{d}{dt} \\arctan \\left(\\frac{\\dot y}{\\dot x}\\right)\\\\\n          &= \\frac{\\dot x \\ddot y - \\dot y \\ddot x}{\\dot x^2 + \\dot y^2}\n\\end{aligned}\n\\]\n\\[\n\\begin{aligned}\n    \\phi &= \\arctan \\frac{L \\dot \\theta}{v}\\\\\n        &= \\arctan \\frac{L(\\dot x \\ddot y - \\dot y \\ddot x)}{(\\dot x^2 + \\dot y^2)^{3/2}}\n\\end{aligned}\n\\]",
    "crumbs": [
      "First Order Systems",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Car</span>"
    ]
  },
  {
    "objectID": "1st_order/car.html#invariance",
    "href": "1st_order/car.html#invariance",
    "title": "5  Car",
    "section": "5.3 Invariance",
    "text": "5.3 Invariance\nThe dynamics are translation-invariant.",
    "crumbs": [
      "First Order Systems",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Car</span>"
    ]
  },
  {
    "objectID": "1st_order/car.html#controllers",
    "href": "1st_order/car.html#controllers",
    "title": "5  Car",
    "section": "5.4 Controllers",
    "text": "5.4 Controllers",
    "crumbs": [
      "First Order Systems",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Car</span>"
    ]
  },
  {
    "objectID": "1st_order/car.html#useful-parameters",
    "href": "1st_order/car.html#useful-parameters",
    "title": "5  Car",
    "section": "5.5 Useful Parameters",
    "text": "5.5 Useful Parameters\n\n5.5.1 car1_v0\n\nA basic version proposed at (Ortiz-Haro et al. (2024)) \\[\n\\begin{aligned}\nL &= 0.25 m\\\\\n\\mathcal{U}&= [-0.1, 0.5] m/s \\times [-\\pi/3, \\pi/3] rad\n\\end{aligned}\n\\]\n\n\n\n\nLaValle, Steven M. 2006. Planning Algorithms. Cambridge University Press.\n\n\nOrtiz-Haro, Joaquim, Wolfgang Hönig, Valentin N. Hartmann, and Marc Toussaint. 2024. “iDb-a*: Iterative Search and Optimization for Optimal Kinodynamic Motion Planning.” IEEE Transactions on Robotics, 1–19. https://doi.org/10.1109/TRO.2024.3502505.",
    "crumbs": [
      "First Order Systems",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Car</span>"
    ]
  },
  {
    "objectID": "2nd_order/multirotor_1d.html",
    "href": "2nd_order/multirotor_1d.html",
    "title": "8  Multirotor (1D)",
    "section": "",
    "text": "8.1 Dynamics",
    "crumbs": [
      "Second Order Systems",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Multirotor (1D)</span>"
    ]
  },
  {
    "objectID": "2nd_order/multirotor_1d.html#dynamics",
    "href": "2nd_order/multirotor_1d.html#dynamics",
    "title": "8  Multirotor (1D)",
    "section": "",
    "text": "Parameters\n\nstate space \\(\\mathcal{X}\\)\naction space \\(\\mathcal{U}\\)\nmass \\(m\\) [kg]\ngravity \\(g\\) [\\(m/s^2\\)]\n\nState: \\(\\mathbf{x}= \\begin{pmatrix}z, \\dot z\\end{pmatrix}^\\top \\in \\mathcal{X}\\) [m, m/s] (height and vertical velocity of the robot in the world frame)\nAction: \\(\\mathbf{u}= \\begin{pmatrix} f_1 \\end{pmatrix}^\\top \\in \\mathcal{U}\\) [N] (upward thrust)\nDynamics: \\[\n      \\begin{aligned}\n      \\mathbf{\\dot x} = f(\\mathbf x, \\mathbf u) = \\begin{pmatrix} \\dot z\\\\ \\frac{f_1}{m} - g \\end{pmatrix}\n      \\end{aligned}\n  \\]",
    "crumbs": [
      "Second Order Systems",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Multirotor (1D)</span>"
    ]
  },
  {
    "objectID": "2nd_order/multirotor_1d.html#differential-flatness",
    "href": "2nd_order/multirotor_1d.html#differential-flatness",
    "title": "8  Multirotor (1D)",
    "section": "8.2 Differential Flatness",
    "text": "8.2 Differential Flatness\nPick flat outputs \\(\\mathbf{z}(t) = (z(t))^\\top\\), i.e., the position of the robot. Then we can compute all necessary variables if \\(\\mathbf{z}(t)\\) is at least C2-continuous. \\[\n\\begin{aligned}\n        \\mathbf{x}(t) &= g_x(\\mathbf{z}, \\dot{\\mathbf{z}}) = \\left(z, \\dot z \\right)\\\\\n        \\mathbf{u}(t) &= g_u(\\ddot{\\mathbf{z}}) = \\left( m ( \\ddot z + g ) \\right)\n      \\end{aligned}\n\\]\n\n\n\n\n\n\nNoteDerivation\n\n\n\n\n\nFollows directly from the dynamics.",
    "crumbs": [
      "Second Order Systems",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Multirotor (1D)</span>"
    ]
  },
  {
    "objectID": "2nd_order/multirotor_1d.html#invariance",
    "href": "2nd_order/multirotor_1d.html#invariance",
    "title": "8  Multirotor (1D)",
    "section": "8.3 Invariance",
    "text": "8.3 Invariance",
    "crumbs": [
      "Second Order Systems",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Multirotor (1D)</span>"
    ]
  },
  {
    "objectID": "2nd_order/multirotor_1d.html#controllers",
    "href": "2nd_order/multirotor_1d.html#controllers",
    "title": "8  Multirotor (1D)",
    "section": "8.4 Controllers",
    "text": "8.4 Controllers",
    "crumbs": [
      "Second Order Systems",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Multirotor (1D)</span>"
    ]
  },
  {
    "objectID": "2nd_order/multirotor_1d.html#useful-parameters",
    "href": "2nd_order/multirotor_1d.html#useful-parameters",
    "title": "8  Multirotor (1D)",
    "section": "8.5 Useful Parameters",
    "text": "8.5 Useful Parameters",
    "crumbs": [
      "Second Order Systems",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Multirotor (1D)</span>"
    ]
  },
  {
    "objectID": "2nd_order/multirotor.html",
    "href": "2nd_order/multirotor.html",
    "title": "11  Multirotor",
    "section": "",
    "text": "11.1 Dynamics",
    "crumbs": [
      "Second Order Systems",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Multirotor</span>"
    ]
  },
  {
    "objectID": "2nd_order/multirotor.html#dynamics",
    "href": "2nd_order/multirotor.html#dynamics",
    "title": "11  Multirotor",
    "section": "",
    "text": "Parameters\n\nstate space \\(\\mathcal{X}\\)\naction space \\(\\mathcal{U}\\)\nnumber of rotors \\(N\\)\nmass \\(m\\) [kg]\nactuation matrix \\(\\mathbf{B}\\in \\mathbb R^{4\\times N}\\)\ninertia matrix \\(\\mathbf{J}\\in \\mathbb R^{3\\times 3}\\) [\\(kg\\cdot m^2\\)]\ngravity constant \\(g\\) [\\(m/s^2\\)]\n\nState: \\(\\mathbf{x}= (\\mathbf{p}, \\mathbf{v}, \\mathbf{R}, \\boldsymbol{\\omega})^\\top \\in \\mathbb R^3 \\times \\mathbb R^3 \\times SO(3) \\times \\mathbb R^3\\)\n\nPosition \\(\\mathbf{p}= (x,y,z)^\\top\\) [m, global frame]\nVelocity \\(\\mathbf{v}= (\\dot x, \\dot y, \\dot z)^\\top\\) [m/s, global frame]\nOrientation \\(\\mathbf{R}\\) [attitude rotation matrix]\nAngular velocity \\(\\boldsymbol{\\omega}= (\\omega_x, \\omega_y, \\omega_z)^\\top\\) [rad/s, body frame]\n\nAction: \\(\\mathbf{u}= (\\omega_1, \\ldots, \\omega_N)^\\top \\in \\mathbb R^N\\)\n\nAngular velocity of each rotor \\(\\omega_i\\) [rad/s]\n\n\n\n11.1.1 Basic Rotation Matrix Formulation\n\\[\n\\begin{aligned}\n    \\dot{\\mathbf{p}} &= \\mathbf{v}\\\\\n    m \\dot{\\mathbf{v}} &= f \\mathbf{R}\\mathbf{e}_z - m g \\mathbf{e}_z\\\\\n    \\dot{\\mathbf{R}} &= \\mathbf{R}\\hat{\\boldsymbol{\\omega}} \\\\\n    \\mathbf{J}\\dot{\\boldsymbol{\\omega}} &= \\mathbf{J}\\boldsymbol{\\omega}\\times \\boldsymbol{\\omega}+ \\boldsymbol{\\tau}_u\\\\\n    (f, \\boldsymbol{\\tau}_u)^\\top &= \\mathbf{B}(\\omega_1^2, \\ldots, \\omega_N^2)^\\top\n\\end{aligned}\n\\] where \\(\\mathbf{e}_z = (0,0,1)^\\top\\) and \\(\\hat{\\boldsymbol{\\omega}}\\) is defined in Equation C.9.\n\n\n\n\n\n\nNote\n\n\n\nWhen integrating, \\(\\mathbf{R}\\) has to be preserve the properties of a rotation matrix.\n\n\n\n\n11.1.2 Basic Quaternion Formulation\nThe state becomes \\(\\mathbf{x}= (\\mathbf{p}, \\mathbf{v}, \\mathbf{q}, \\boldsymbol{\\omega})^\\top \\in \\mathbb R^3 \\times \\mathbb R^3 \\times SO(3) \\times \\mathbb R^3\\)\n\\[\n\\begin{aligned}\n    \\dot{\\mathbf{p}} &= \\mathbf{v}\\\\\n    m \\dot{\\mathbf{v}} &= \\mathbf{q} \\odot (0, 0, f)^\\top - m g \\mathbf{e}_z\\\\\n    \\dot{\\mathbf{q}} &= \\frac{1}{2} \\mathbf{q}\\otimes  \\overline{\\boldsymbol{\\omega}} \\\\\n    \\mathbf{J}\\dot{\\boldsymbol{\\omega}} &= \\mathbf{J}\\boldsymbol{\\omega}\\times \\boldsymbol{\\omega}+ \\boldsymbol{\\tau}_u\\\\\n    (f, \\boldsymbol{\\tau}_u)^\\top &= \\mathbf{B}(\\omega_1^2, \\ldots, \\omega_N^2)^\\top\n\\end{aligned}\n\\] where \\(\\mathbf{q}\\) is a unit quaternion, \\(\\overline{\\boldsymbol{\\omega}}\\) is defined in Equation C.3, \\(\\otimes\\) is defined in Equation C.7, and \\(\\odot\\) is defined in Equation C.8.\n\n\n11.1.3 Basic Dual-Quaternion Formulation\n\n\n11.1.4 Motor-Delay Formulation",
    "crumbs": [
      "Second Order Systems",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Multirotor</span>"
    ]
  },
  {
    "objectID": "2nd_order/multirotor.html#differential-flatness",
    "href": "2nd_order/multirotor.html#differential-flatness",
    "title": "11  Multirotor",
    "section": "11.2 Differential Flatness",
    "text": "11.2 Differential Flatness\n\n\n\n\n\n\n\nNoteDerivation",
    "crumbs": [
      "Second Order Systems",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Multirotor</span>"
    ]
  },
  {
    "objectID": "2nd_order/multirotor.html#invariance",
    "href": "2nd_order/multirotor.html#invariance",
    "title": "11  Multirotor",
    "section": "11.3 Invariance",
    "text": "11.3 Invariance\nThe dynamics are translation-invariant.",
    "crumbs": [
      "Second Order Systems",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Multirotor</span>"
    ]
  },
  {
    "objectID": "2nd_order/multirotor.html#controllers",
    "href": "2nd_order/multirotor.html#controllers",
    "title": "11  Multirotor",
    "section": "11.4 Controllers",
    "text": "11.4 Controllers\n\n11.4.1 Geometric Controller (Lee, Leok, and McClamroch (2010))\n\nGiven reference trajectory tuple: \\(\\mathbf{r}_d  = (\\ddddot{\\mathbf{p}}_d(t), \\dddot{\\mathbf{p}}_d(t), \\ddot{\\mathbf{p}}_d(t), \\dot{\\mathbf{p}}_d(t), \\mathbf{p}_d(t), \\psi_d(t), \\dot{\\psi}_d(t), \\ddot{\\psi}_d(t))\\) (i.e, desired snap, jerk, acceleration, velocity, position, heading, angular velocity for heading, acceleration for heading)\n\\(\\mathbf{K}_p, \\mathbf{K}_v, \\mathbf{K}_R, \\mathbf{K}_\\omega \\in\\mathbb R^{3\\times 3}\\) are tuning matrices (typically only positive diagonal entries, so 12 parameters)\nControl law: \\[\\begin{aligned}\n\\mathbf{e}_p &= \\mathbf{p}_d - \\mathbf{p}\\\\\n\\mathbf{e}_v &= \\dot{\\mathbf{p}}_d - \\dot{\\mathbf{p}}\\\\\n\\mathbf{e}_R &= \\frac{1}{2} \\left( \\mathbf{R}^\\top_d \\mathbf{R}- \\mathbf{R}^\\top \\mathbf{R}_d \\right)^\\vee\\\\\n\\mathbf{e}_\\omega &= \\boldsymbol{\\omega}- \\mathbf{R}^\\top \\mathbf{R}_d \\boldsymbol{\\omega}_d\\\\\nf &=  m(\\ddot{\\mathbf{p}}_d + \\mathbf{K}_p \\mathbf{e}_p + \\mathbf{K}_v \\mathbf{e}_v + g \\mathbf{e}_z) \\cdot \\mathbf{R}\\mathbf{e}_z\\\\\n\\boldsymbol{\\tau}_u &= -\\mathbf{K}_R \\mathbf{e}_R - \\mathbf{K}_\\omega \\mathbf{e}_\\omega + \\boldsymbol{\\omega}\\times \\mathbf{J}\\boldsymbol{\\omega}- \\mathbf{J}(\\hat{\\boldsymbol{\\omega}} \\mathbf{R}^\\top \\mathbf{R}_d \\boldsymbol{\\omega}_d - \\mathbf{R}^\\top \\mathbf{R}_d \\dot{\\boldsymbol{\\omega}}_d)\\\\\n(\\omega_1^2, \\ldots, \\omega_N^2)^\\top &= \\mathbf{B}^{-1} (f, \\boldsymbol{\\tau}_u)^\\top \\text{(or solving a QP, see also action mixing below.)}\n\\end{aligned}\n\\] where \\((\\cdot)^\\vee\\) is defined below Equation C.9.\n\nThe additional reference signals \\(\\mathbf{R}_d\\), \\(\\boldsymbol{\\omega}_d\\), and \\(\\dot{\\boldsymbol{\\omega}}_d\\) can be computed via differential flatness as follows:\n\\[\n\\begin{aligned}\n\\mathbf{x}_{c_d} &= \\begin{bmatrix} \\cos(\\psi_d) & \\sin(\\psi_d) & 0\\end{bmatrix}^\\top &\n\\mathbf{y}_{c_d} &= \\begin{bmatrix} -\\sin(\\psi_d) & \\cos(\\psi_d) & 0\\end{bmatrix}^\\top\\\\\n\\mathbf{x}_{b_d} &= n(\\mathbf{y}_{c_d} \\times \\mathbf{F}_d) &\n\\mathbf{y}_{b_d} &= n(\\mathbf{F}_d \\times \\mathbf{x}_{b_d}) &\n\\mathbf{z}_{b_d} &= \\mathbf{x}_{b_d} \\times \\mathbf{y}_{b_d}\\\\\n\\mathbf{R}_d &= \\begin{bmatrix} \\mathbf{x}_{b_d} & \\mathbf{y}_{b_d} & \\mathbf{z}_{b_d} \\end{bmatrix}\\\\\nc &= \\mathbf{z}_{b_d}^\\top (\\ddot{\\mathbf{p}}_d + g \\mathbf{e}_z) &\nd_1 &= \\mathbf{x}_{b_d}^\\top \\dddot{\\mathbf{p}}_d &\nd_2 &= -\\mathbf{y}_{b_d}^\\top \\dddot{\\mathbf{p}}_d \\\\\nb_3 &= -\\mathbf{y}_{c_d}^\\top \\mathbf{z}_{b_d} &\nc_3 &= \\| \\mathbf{y}_{c_d} \\times \\mathbf{z}_{b_d} \\| &\nd_3 &= \\dot \\psi_d \\mathbf{x}_{c_d}^\\top \\mathbf{x}_{b_d}\\\\\n\\omega_x &= \\frac{d_2}{c} &\n\\omega_y &= \\frac{d_1}{c} &\n\\omega_z &= \\frac{c d_3 - b_3 d_1}{c c_3}\\\\\n\\boldsymbol{\\omega}_d &= \\begin{bmatrix} \\omega_x & \\omega_y & \\omega_z \\end{bmatrix}^\\top\\\\\n\\dot{c} &= \\mathbf{z}_b^\\top \\dddot{\\mathbf{p}}\\\\\ne_1 &= \\mathbf{x}_{b_d}^\\top \\ddddot{\\mathbf{p}}_d - 2\\dot{c} \\omega_y - c \\omega_x \\omega_z &\ne_2 &= -\\mathbf{y}_{b_d}^\\top \\ddddot{\\mathbf{p}}_d - 2\\dot{c} \\omega_x + c \\omega_y \\omega_z &\ne_3 &= \\ddot{\\psi}_d \\mathbf{x}_{c_d}^\\top \\mathbf{x}_{b_d} + 2 \\dot{\\psi}_d \\omega_z \\mathbf{x}_{c_d}^\\top \\mathbf{y}_{b_d} \\\\\n    &&&&&- 2 \\dot{\\psi}_d \\omega_y \\mathbf{x}_{c_d}^\\top \\mathbf{z}_{b_d} - \\omega_x \\omega_y \\mathbf{y}_{c_d}^\\top \\mathbf{y}_{b_d} \\\\\n    &&&&&- \\omega_x \\omega_z \\mathbf{y}_{c_d}^\\top \\mathbf{z}_{b_d}\\\\\n\\dot{\\omega}_x &= \\frac{e_2}{c}&\n\\dot{\\omega}_y &= \\frac{e_1}{c}&\n\\dot{\\omega}_z &= \\frac{c e_3 - b_3 e_1}{c c_3}\\\\\n\\dot{\\boldsymbol{\\omega}}_d &= \\begin{bmatrix} \\dot{\\omega}_x & \\dot{\\omega}_y & \\dot{\\omega}_z \\end{bmatrix}^\\top\n\\end{aligned}\n\\]\n\n\n\n\n\n\nNote\n\n\n\nNote that \\(\\omega_z\\) is wrong in (Mellinger and Kumar 2011). Details are in (Faessler, Franchi, and Scaramuzza 2018) (Appendix A), from which we obtained the results.\n\n\n\n\n11.4.2 Action Mixing",
    "crumbs": [
      "Second Order Systems",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Multirotor</span>"
    ]
  },
  {
    "objectID": "2nd_order/multirotor.html#useful-parameters",
    "href": "2nd_order/multirotor.html#useful-parameters",
    "title": "11  Multirotor",
    "section": "11.5 Useful Parameters",
    "text": "11.5 Useful Parameters\n\n\n\n\nFaessler, Matthias, Antonio Franchi, and Davide Scaramuzza. 2018. “Differential Flatness of Quadrotor Dynamics Subject to Rotor Drag for Accurate Tracking of High-Speed Trajectories.” IEEE Robotics and Automation Letters 3 (2): 620–26. https://doi.org/10.1109/LRA.2017.2776353.\n\n\nLee, Taeyoung, Melvin Leok, and N. Harris McClamroch. 2010. “Geometric Tracking Control of a Quadrotor UAV on SE(3).” In IEEE Conference on Decision and Control (CDC), 5420–25. https://doi.org/10.1109/CDC.2010.5717652.\n\n\nMellinger, Daniel, and Vijay Kumar. 2011. “Minimum Snap Trajectory Generation and Control for Quadrotors.” In 2011 IEEE International Conference on Robotics and Automation, 2520–25. https://doi.org/10.1109/ICRA.2011.5980409.",
    "crumbs": [
      "Second Order Systems",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Multirotor</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Choset, Howie, Kevin M. Lynch, Seth Hutchinson, George A. Kantor,\nWolfram Burgard, Lydia E. Kavraki, and Sebastian Thrun. 2005.\nPrinciples of Robot Motion: Theory, Algorithms, and\nImplementations. Edited by Ronald C. Arkin. Intelligent Robotics\nand Autonomous Agents Series. Cambridge, MA, USA: A Bradford Book.\n\n\nFaessler, Matthias, Antonio Franchi, and Davide Scaramuzza. 2018.\n“Differential Flatness of Quadrotor Dynamics Subject to Rotor Drag\nfor Accurate Tracking of High-Speed Trajectories.” IEEE\nRobotics and Automation Letters 3 (2): 620–26. https://doi.org/10.1109/LRA.2017.2776353.\n\n\nHuynh, Du Q. 2009. “Metrics for 3D Rotations: Comparison and\nAnalysis.” Journal of Mathematical Imaging and Vision 35\n(2): 155–64. https://doi.org/10.1007/s10851-009-0161-2.\n\n\nJia, Prof. Yan-Bin. 2024. “Quaternions (Com s 477/577\nNotes).” 2024. https://faculty.sites.iastate.edu/jia/files/inline-files/quaternion.pdf.\n\n\nKanayama, Y., Y. Kimura, F. Miyazaki, and T. Noguchi. 1990. “A\nStable Tracking Control Method for an Autonomous Mobile Robot.”\nIn IEEE International Conference on Robotics and Automation\n(ICRA), 384–89. https://doi.org/10.1109/ROBOT.1990.126006.\n\n\nLaValle, Steven M. 2006. Planning Algorithms. Cambridge\nUniversity Press.\n\n\nLee, Taeyoung, Melvin Leok, and N. Harris McClamroch. 2010.\n“Geometric Tracking Control of a Quadrotor UAV on SE(3).”\nIn IEEE Conference on Decision and Control (CDC), 5420–25. https://doi.org/10.1109/CDC.2010.5717652.\n\n\nMellinger, Daniel, and Vijay Kumar. 2011. “Minimum Snap Trajectory\nGeneration and Control for Quadrotors.” In 2011 IEEE\nInternational Conference on Robotics and Automation, 2520–25. https://doi.org/10.1109/ICRA.2011.5980409.\n\n\nNarayan, Dr. Ashwin. 2017. “How to Integrate Quaternions.”\n2017. https://www.ashwinnarayan.com/post/how-to-integrate-quaternions/.\n\n\nOrtiz-Haro, Joaquim, Wolfgang Hönig, Valentin N. Hartmann, and Marc\nToussaint. 2024. “iDb-a*: Iterative Search and Optimization for\nOptimal Kinodynamic Motion Planning.” IEEE Transactions on\nRobotics, 1–19. https://doi.org/10.1109/TRO.2024.3502505.\n\n\nSärkkä, Prof. Simo. 2007. “Notes on Quaternions.” 2007. https://users.aalto.fi/~ssarkka/pub/quat.pdf.\n\n\nSchuck, Martin, Sherif Samy, and Angela P. Schoellig. 2025. “A\nPrimer on SO(3) Action Representations in Deep Reinforcement\nLearning.” October 13, 2025. https://doi.org/10.48550/arXiv.2510.11103.\n\n\nShoemake, Ken. 1992. “Uniform Random Rotations.” In\nGraphics Gems III, 124–32. USA: Academic Press Professional,\nInc.\n\n\nToussaint, Prof. Marc. 2024. “Lecture Note: Quaternions,\nExponential Map, and Quaternion Jacobians.” 2024. https://www.user.tu-berlin.de/mtoussai/notes/quaternions.html.",
    "crumbs": [
      "References"
    ]
  },
  {
    "objectID": "so3.html",
    "href": "so3.html",
    "title": "Appendix C — SO(3) - Rotations in 3D",
    "section": "",
    "text": "C.1 Introduction\nFor rotations without singularities, rotation matrices and quaternions are common. The special orthogonal group SO(3) is often defined using a constrained set of \\(3\\times 3\\) rotation matrices: \\[\nSO(3)=\\{ R \\in \\mathbb R^{3 \\times 3} | R^\\top R = R R^\\top = I \\land \\det R = 1 \\}\n\\tag{C.1}\\]\nQuaternions have the advantage of a lower memory requirement (4 floats vs. 9 in a rotation matrix), often lower computational effort, and that their constraints are easier to fulfill when integrating (one norm constraint rather than the two constraints above). This document summarizes the mathematical operations for quaternions and provides useful references for derivations.\nNotable implementations for quaternions are:\nNotable other references are: Särkkä (2007), Toussaint (2024), Jia (2024).",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>SO(3) - Rotations in 3D</span>"
    ]
  },
  {
    "objectID": "so3.html#introduction",
    "href": "so3.html#introduction",
    "title": "Appendix C — SO(3) - Rotations in 3D",
    "section": "",
    "text": "Language\nLink\n\n\n\n\nPython\nRowan\n\n\nC++\nEigen, Sophus\n\n\nC\ncmath3d",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>SO(3) - Rotations in 3D</span>"
    ]
  },
  {
    "objectID": "so3.html#quaternions",
    "href": "so3.html#quaternions",
    "title": "Appendix C — SO(3) - Rotations in 3D",
    "section": "C.2 Quaternions",
    "text": "C.2 Quaternions\n\nC.2.1 Definition\nA quaternion for SO(3) is a 4D vector with the constraint to have norm 1:\n\\[\n    \\mathbf{q}=\\begin{pmatrix}\n        q_w\\\\\n        q_x\\\\\n        q_y\\\\\n        q_z\n    \\end{pmatrix}=\n    \\begin{pmatrix}\n        q_w\\\\\n        \\vec{\\mathbf{q}}\n    \\end{pmatrix}\\in \\mathbb R^4 \\,\\, s.t. \\| \\mathbf{q}\\|_2 = 1\n\\tag{C.2}\\]\nOne can augment or promote a vector \\(\\mathbf{v}\\in \\mathbb R^3\\) to be a quaternion: \\[\n    \\bar{\\mathbf{v}} = \\begin{pmatrix}\n        0\\\\\n        \\mathbf{v}\n    \\end{pmatrix}\n\\tag{C.3}\\]\nOne can extract the vector or imaginary part of a quaternion: \\[\n    \\vec{\\mathbf{q}} = \\mathop{\\mathrm{Im}}(\\mathbf{q})\n\\tag{C.4}\\]\n\n\n\n\n\n\nWarning\n\n\n\nNote that the order of the components is not uniquely defined. Some software packages put \\(q_w\\) first, some last in the vector.\n\n\n\n\nC.2.2 Conversion\n\nC.2.2.1 To Rotation Matrix\n\n\\[\nR(\\mathbf{q}) = \\begin{pmatrix}\nq_w^2 + q_x^2 - q_y^2 - q_z^2 &  2(q_x q_y - q_w q_z) &  2(q_w q_y + q_x q_z) \\\\\n2(q_x q_y + q_w q_z) & q_w^2 - q_x^2 + q_y^2 - q_z^2 &  2(q_y q_z - q_w q_x) \\\\\n2(q_x q_z - q_w q_y) & 2( q_w q_x + q_y q_z) & q_w^2 - q_x^2 - q_y^2 + q_z^2\n\\end{pmatrix}\n\\tag{C.5}\\]\n\n\nC.2.2.2 From Rotation Matrix\n\n\n\n\nC.2.3 Low-Level Operations\n\nC.2.3.1 Negation\n(same as any vector):\n\\[\n-\\mathbf{q}= \\begin{pmatrix}\n        -q_w\\\\\n        -q_x\\\\\n        -q_y\\\\\n        -q_z\n    \\end{pmatrix}\n\\tag{C.6}\\]\n\n\n\n\n\n\nNote\n\n\n\n\\(\\mathbf{q}\\) and \\(-\\mathbf{q}\\) represent the same rotation.\n\n\n\n\nC.2.3.2 Addition, Substraction, Multiplication/Devision with Scalar\nsame as any vector, e.g.,:\n\\[\n\\mathbf{q}+ \\mathbf{p}= \\begin{pmatrix}\n        q_w + p_w\\\\\n        q_x + p_x\\\\\n        q_y + p_y\\\\\n        q_z + p_z\n    \\end{pmatrix}\n\\]\n\n\nC.2.3.3 Conjugate\n\\[\n\\mathbf{q}^* = \\begin{pmatrix}\n        q_w\\\\\n        -q_x\\\\\n        -q_y\\\\\n        -q_z\n    \\end{pmatrix}\n\\]\n\n\n\n\n\n\nNote\n\n\n\nThis is the inverse for normalized quaternions.\n\n\n\n\nC.2.3.4 Norm\n(regular \\(L_2\\) norm on the vector)\n\\[\n\\| \\mathbf{q}\\| = \\sqrt{q_w^2 + q_x^2 + q_y^2 + q_z^2}\n\\]\n\n\n\n\n\n\nNote\n\n\n\nThis should be always 1 for normalized quaternions.\n\n\n\n\n\nC.2.3.5 Exponential\n\\[\n\\exp{(\\mathbf{q})} = \\exp{(q_w)} \\begin{pmatrix}\n\\cos{(\\| \\vec{\\mathbf{q}} \\|)}\\\\\n\\frac{\\vec{\\mathbf{q}}}{\\| \\vec{\\mathbf{q}} \\|} \\sin{(\\| \\vec{\\mathbf{q}} \\|)}\n\\end{pmatrix}\n\\]\n\n\nC.2.3.6 Logarithm\n\\[\n\\ln{(\\mathbf{q})} = \\begin{pmatrix}\n\\ln{(\\| \\mathbf{q}\\|)}\\\\\n\\frac{\\vec{\\mathbf{q}}}{\\| \\vec{\\mathbf{q}} \\|} \\arccos{\\left( \\frac{q_w}{\\| \\mathbf{q}\\| }\\right)}\n\\end{pmatrix}\n\\]\n\n\nC.2.3.7 Power with Real Number\n\\[\n\\mathbf{q}^p = \\exp{(\\ln(\\mathbf{q}) p)}\n\\]\n\n\nC.2.3.8 Power with Quaternion\n\\[\n\\mathbf{q}^\\mathbf{p}= \\exp{(\\ln(\\mathbf{q}) \\otimes \\mathbf{p})}\n\\]\n\n\n\nC.2.4 Useful Operations\n\nC.2.4.1 Multiplication\nSimilar to rotation matrices, this can be used to concatenate rotations.\n\\[\n\\mathbf{q}\\otimes \\mathbf{p}= \\begin{pmatrix}\nq_w p_w - q_x p_x - q_y p_y - q_z p_z\\\\\nq_x p_w + q_w p_x - q_z p_y + q_y p_z\\\\\nq_y p_w + q_z p_x + q_w p_y - q_x p_z\\\\\nq_z p_w - q_y p_x + q_x p_y + q_w p_z\n\\end{pmatrix}\n\\tag{C.7}\\]\n\n\n\n\n\n\nNote\n\n\n\nGenerally \\(\\mathbf{q}\\otimes \\mathbf{p}\\neq \\mathbf{p}\\otimes \\mathbf{q}\\).\n\n\n\n\n\n\n\n\nWarning\n\n\n\nBe careful when looking at papers - sometimes it’s defined inverse!\n\n\n\n\n\nC.2.5 Vector Rotation\nWith a rotation matrix \\(\\mathbf R(\\mathbf{q})\\), we can rotate a vector \\(\\mathbf v\\) as \\(\\mathbf v_{rotated} = \\mathbf R(\\mathbf{q}) \\mathbf v\\). Similarily, for quaternions we have:\n\\[\n\\mathbf{v}_{rotated} = \\mathbf{q}\\odot \\mathbf{v}= \\mathop{\\mathrm{Im}}(\\mathbf{q}\\otimes \\overline{\\mathbf{v}} \\otimes \\mathbf{q}^*)\n\\tag{C.8}\\]\n(I.e., augment \\(\\mathbf v\\) to a quaternion, use two quaternion multiplications, and one conjugate, and then extract the vector part of the result.)\n\n\n\n\nC.2.6 Derivatives and Integration\nAssuming \\(\\boldsymbol{\\omega}\\in \\mathbb R^3\\) is the angular velocity in (e.g., gyroscope): \\[\n\\dot{\\mathbf{q}} = \\frac{1}{2} \\mathbf{q}\\otimes \\overline{\\boldsymbol{\\omega}}\n\\]\nAssuming \\(\\boldsymbol{\\omega}\\) in world frame: \\[\n\\dot{\\mathbf{q}} = \\frac{1}{2} \\overline{\\boldsymbol{\\omega}} \\otimes \\mathbf{q}\n\\]\nThis can also be used to numerically estimate \\(\\boldsymbol{\\omega}\\). One can approximate \\(\\dot{\\mathbf{q}} \\approx (\\mathbf{q}(t+\\Delta t) - \\mathbf{q}(t)) / \\Delta t\\) and then proceed (remembering to use \\(\\mathbf{q}^*\\) as inverse of \\(\\mathbf{q}\\)). A nicer solution can be derived to reach the following (body frame)1: \\[\n\\boldsymbol{\\omega} \\approx\n2 \\mathop{\\mathrm{Im}}\\left( \\frac{\\mathbf{q}^*(t) \\otimes \\mathbf{q}(t+\\Delta t)}{\\Delta t} \\right)\n\\]\nOr similarly in world frame: \\[\n\\boldsymbol{\\omega} \\approx\n2 \\mathop{\\mathrm{Im}}\\left( \\frac{ \\mathbf{q}(t+\\Delta t) \\otimes \\mathbf{q}^*(t)}{\\Delta t} \\right)\n\\]\nFor integration, one can use Euler or RK4 to integrate \\(\\mathbf{q}\\), followed by normalizing the quaternion. Alternatively, the exponential map can be used as a more accurate, explicit integrator (body frame):\n\\[\n\\mathbf{q}_{t+\\Delta t} = \\mathbf{q}_t \\otimes \\begin{pmatrix}\n\\cos{(\\| \\boldsymbol{\\omega} \\| \\Delta t/2)}\\\\\n\\frac{\\boldsymbol{\\omega}}{\\| \\boldsymbol{\\omega} \\|} \\sin{(\\|\\boldsymbol{\\omega}\\| \\Delta t/2)}\n\\end{pmatrix}\n\\]\nA derivation is in Narayan (2017).\n\n\n\n\n\n\nWarning\n\n\n\nSome libraries do not specify which frame they operate in, e.g., the Python library rowan assumes world frame for its methods.\n\n\n\n\nC.2.7 Interpolation\nIf we want to linearly interpolate from a rotation \\(\\mathbf{q}(0)\\) to another rotation \\(\\mathbf{q}(1)\\), we can use the slerp operation: \\[\n\\mathbf{q}(t) = \\left( \\mathbf{q}(1) \\otimes \\mathbf{q}(0)^* \\right)^t \\otimes \\mathbf{q}(0) \\,\\,\\, \\forall t \\in [0, 1]\n\\]\n\n\nC.2.8 Metrics\nA metric measures the difference between two rotations as a scalar value. A comparison of different metrics is in Huynh (2009). Below are common metrics.\n\nThe following is metric 2 in Huynh (2009) and sym_distance in rowan: \\[\nd(\\mathbf{q}, \\mathbf{p}) = \\min \\left( \\| \\mathbf{q}- \\mathbf{p}\\|, \\| \\mathbf{q}+ \\mathbf{p}\\| \\right) \\in [0, \\sqrt 2]\n\\]\n\nThe following is metric 3 in Huynh (2009), is used by OMPL, and called sym_intrinsic_distance in rowan: \\[\nd(\\mathbf{q}, \\mathbf{p}) = \\arccos{| \\mathbf{q}\\cdot \\mathbf{p}|} \\in [0, \\pi/2]\n\\]\n\nThe following is metric 4 in Huynh (2009): \\[\nd(\\mathbf{q}, \\mathbf{p}) = 1 - | \\mathbf{q}\\cdot \\mathbf{p}| \\in [0, 1]\n\\]\n\n\nC.2.9 Random Generation\n\nSampling rotations uniformly is not trivial. Here is one approach Shoemake (1992): \\[\n\\begin{aligned}\n    r_1, r_2, r_3 &\\sim \\mathcal U(0, 1)\\\\\n    \\mathbf{q}&=\\begin{pmatrix}\n        \\sqrt{1-r_1} \\sin 2\\pi r_2\\\\\n        \\sqrt{1-r_1} \\cos 2\\pi r_2\\\\\n        \\sqrt{r_1} \\sin 2\\pi r_3\\\\\n        \\sqrt{r_1} \\cos 2\\pi r_3\n    \\end{pmatrix}\n\\end{aligned}\n\\]\nNote, this is also used inside OMPL.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>SO(3) - Rotations in 3D</span>"
    ]
  },
  {
    "objectID": "so3.html#rotation-matrices",
    "href": "so3.html#rotation-matrices",
    "title": "Appendix C — SO(3) - Rotations in 3D",
    "section": "C.3 Rotation Matrices",
    "text": "C.3 Rotation Matrices\n\nC.3.1 Skew-symmetric Mapping\nThe hat-map constructs a metrix from a vector: \\(\\mathbb R^3 \\to \\mathbb R^{3\\times 3}\\) \\[\n\\hat{\\boldsymbol{\\omega}} = \\begin{bmatrix}\n0 & -\\boldsymbol{\\omega}_z & \\boldsymbol{\\omega}_y\\\\\n\\boldsymbol{\\omega}_z & 0 & -\\boldsymbol{\\omega}_x\\\\\n-\\boldsymbol{\\omega}_y & \\boldsymbol{\\omega}_x & 0\n\\end{bmatrix}\n\\tag{C.9}\\]\nThe vee-map \\(\\mathbf{R}^{\\vee}\\) does the inverse operation.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>SO(3) - Rotations in 3D</span>"
    ]
  },
  {
    "objectID": "so3.html#machine-learning",
    "href": "so3.html#machine-learning",
    "title": "Appendix C — SO(3) - Rotations in 3D",
    "section": "C.4 Machine Learning",
    "text": "C.4 Machine Learning\nSchuck, Samy, and Schoellig (2025)\n\n\n\n\n\nHuynh, Du Q. 2009. “Metrics for 3D Rotations: Comparison and Analysis.” Journal of Mathematical Imaging and Vision 35 (2): 155–64. https://doi.org/10.1007/s10851-009-0161-2.\n\n\nJia, Prof. Yan-Bin. 2024. “Quaternions (Com s 477/577 Notes).” 2024. https://faculty.sites.iastate.edu/jia/files/inline-files/quaternion.pdf.\n\n\nNarayan, Dr. Ashwin. 2017. “How to Integrate Quaternions.” 2017. https://www.ashwinnarayan.com/post/how-to-integrate-quaternions/.\n\n\nSärkkä, Prof. Simo. 2007. “Notes on Quaternions.” 2007. https://users.aalto.fi/~ssarkka/pub/quat.pdf.\n\n\nSchuck, Martin, Sherif Samy, and Angela P. Schoellig. 2025. “A Primer on SO(3) Action Representations in Deep Reinforcement Learning.” October 13, 2025. https://doi.org/10.48550/arXiv.2510.11103.\n\n\nShoemake, Ken. 1992. “Uniform Random Rotations.” In Graphics Gems III, 124–32. USA: Academic Press Professional, Inc.\n\n\nToussaint, Prof. Marc. 2024. “Lecture Note: Quaternions, Exponential Map, and Quaternion Jacobians.” 2024. https://www.user.tu-berlin.de/mtoussai/notes/quaternions.html.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>SO(3) - Rotations in 3D</span>"
    ]
  },
  {
    "objectID": "so3.html#footnotes",
    "href": "so3.html#footnotes",
    "title": "Appendix C — SO(3) - Rotations in 3D",
    "section": "",
    "text": "See this math.stackexchange post.↩︎",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>SO(3) - Rotations in 3D</span>"
    ]
  },
  {
    "objectID": "python_playground.html",
    "href": "python_playground.html",
    "title": "Appendix D — Python Playground",
    "section": "",
    "text": "D.1 MeshCat\nCode\nvis[\"box1\"].set_object(Box([0.1, 0.2, 0.3]))\n\nanim = Animation()\n\nwith anim.at_frame(vis, 0) as frame:\n    frame[\"box1\"].set_transform(tf.translation_matrix([0, 0, 0]))\nwith anim.at_frame(vis, 30) as frame:\n    frame[\"box1\"].set_transform(tf.translation_matrix([0, 1, 0]))\n    \nvis.set_animation(anim)\nvis.render_static()",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>Python Playground</span>"
    ]
  },
  {
    "objectID": "rust_playground.html",
    "href": "rust_playground.html",
    "title": "Appendix E — Rust Playground",
    "section": "",
    "text": "Code\nprintln!(\"Hello Rust!\");\n\n\nHello Rust!",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>E</span>  <span class='chapter-title'>Rust Playground</span>"
    ]
  }
]