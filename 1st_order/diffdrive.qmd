::: {.content-visible unless-format="pdf"}
{{< include ../macros.tex >}}
:::

# Differential Drive

![Differential Drive Robot (Picture from @lavallePlanningAlgorithms2006)](../media/lavalle_13.2b.png)

## Dynamics

- Parameters
    - $r$: radius of the wheels [m]
    - $L$: distance between the wheels [m]
- State: $\vx = \begin{pmatrix}x, y, \theta\end{pmatrix}^\top$ [m, m, rad] (position and orientation of the robot in the world frame)
- Action: $\vu = \begin{pmatrix} u_l, u_r \end{pmatrix}^\top$ [rad/s, rad/s] (angular velocity of the left and right wheels, respectively)
- Dynamics: 
    $$
    \begin{aligned}
        \dot x &= \frac{r}{2} (u_l + u_r) \cos \theta \\
        \dot y &= \frac{r}{2} (u_l + u_r) \sin \theta \\
        \dot \theta &= \frac{r}{L} (u_r - u_l)
    \end{aligned}
    $$

### Relationship to Unicycle

There is a linear relationship between the differential drive and the unicycle. One can substitute actions to $v = \frac{r}{2} (u_l + u_r)$ and $\omega = \frac{r}{L} (u_r - u_l)$ to get
$$ 
\begin{aligned}
        \dot x &= v \cos \theta \\
        \dot y &= v \sin \theta \\
        \dot \theta &= \omega
    \end{aligned}
$$

Then, the "original" actions can be computed as
$$\begin{aligned}
    u_l &= \frac{2v-L\omega}{2r}\\
    u_r &= \frac{2v + L\omega}{2r}
\end{aligned}
$$

::: {.callout-note collapse="true"}
## Derivation

$$
2v = r (u_l + u_r)
$$ {#eq-diffdrive-v}

$$
L\omega = r (u_r - u_l)
$$ {#eq-diffdrive-w}

Adding @eq-diffdrive-v and @eq-diffdrive-w:

$$
\begin{aligned}
2v + L\omega = r (u_l + u_r + u_r - u_l) = 2 r u_r\\
u_r = \frac{2v + L\omega}{2 r}
\end{aligned}
$$ {#eq-diffdrive-ur}

Substituting @eq-diffdrive-ur in @eq-diffdrive-v:
$$
\begin{aligned}
2v = r (u_l + u_r) = r (u_l + \frac{2v + L\omega}{2 r}) = r u_l + v + \frac{L\omega}{2}\\
u_l = \frac{2v - v - \frac{L\omega}{2}}{r} = \frac{2v - L \omega}{2 r}
\end{aligned}
$$ {#eq-diffdrive-ul}
:::


## Differential Flatness

Pick *flat outputs* $\vz(t) = (x(t), y(t))^\top$, i.e., the position of the robot. Then we can compute all necessary variables if $\vz(t)$ is at least C2-continuous.
$$
\begin{aligned}
    \vx(t) &= g_x(\vz, \dot{\vz}) = \left(x, y, \arctan \left(\frac{\dot y}{\dot x}\right)\right)\\
    \vu(t) &= g_u(\dot{\vz}, \ddot{\vz}) = \left(\frac{2v-L\omega}{2r}, \frac{2v + L\omega}{2r}\right), \text{ where }\\
    v &= {\color{red} \pm}\sqrt{\dot y^2 + \dot x^2}\\
    \omega &= \frac{\dot x \ddot y - \dot y \ddot x}{\dot x^2 + \dot y^2}
\end{aligned}
$$



::: {.callout-note collapse="true"}
## Derivation

One can apply the same differential flatness result from the unicycle, followed by the linear mapping derived earlier to recover the actual actions $g_u$.
:::

## Invariance

The dynamics are translation-invariant.

## Controllers

### Geometric Controller (@UGVTrajectoryController)

This is the same controller as for the unicycle, with the linear mapping applied.

- Given reference state $\vx_r = \begin{pmatrix}x_r, y_r, \theta_r\end{pmatrix}^\top \in \sX$ and reference action $\vu_r = \begin{pmatrix} u_{l,r}, u_{r,r} \end{pmatrix}^\top \in \sU$
- $K_x, K_y, K_\theta\in\mathbb R^+$ are tuning gains 
- Control law:
    $$\begin{aligned}
    v_r &= \frac{r}{2} (u_{l,r} + u_{r,r})\\
    \omega_r &= \frac{r}{L} (u_{r,r} - u_{l,r})\\
    x_e &= (x_r-x)\cos \theta + (y_r-y)\sin \theta\\
    y_e &= -(x_r-x)\sin \theta + (y_r-y)\cos \theta\\
    \theta_e &= \theta_d \ominus \theta \\
    v &= v_r \cos \theta_e + K_x x_e\\
    \omega &= \omega_r + v_r (K_y y_e + K_\theta \sin \theta_e)\\
    u_l &= \frac{2v-L\omega}{2r}\\
    u_r &= \frac{2v + L\omega}{2r}
    \end{aligned}
    $$

### Action Mixing

Geometric controllers might output actions that are outside the nominal action space $\sU$ (saturation limits). To remedy this, a QP can be used that prefers $\omega$ over $v$ using a tuning parameter $\lambda$:

$$
\begin{aligned}
\min_{v^*, \omega^*} & \, (\omega^* - \omega) ^2 + \lambda (v^* - v)^2 \\
\text{s.t.} & \, 
\begin{pmatrix} \frac{2v^*-L\omega^*}{2r}, \frac{2v^* + L\omega^*}{2r} \end{pmatrix}^\top \in \sU
\end{aligned}
$$

followed by converting the result back to the desired control values:

$$\begin{aligned}
u_l &= \frac{2v^*-L\omega^*}{2r}\\
u_r &= \frac{2v^* + L\omega^*}{2r}
\end{aligned}
$$


## Useful Parameters

### pololu-3piplus-hyper

Commercially off-the-shelves (Cots) robot: [Pololu 3pi+ Hyper Edition](https://www.pololu.com/product/5000)

$$\begin{aligned}
L &= 0.089\\
r &= 0.016\\
\sU &= [-157.08, 157.08] rad/s \times [-157.08, 157.08] rad/s
\end{aligned}
$$
